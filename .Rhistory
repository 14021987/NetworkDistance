count[K] = count[K]+(length(eig)-sum(count))
}
return(count)
}
eig = runif(10)
eig
grid = seq(from=0,to=1.5,length.out=11)
wsd_bincount(eig,grid)
(eig>grid[1])
(eig<grid[2])
(eig<grid[2])*(eig>grid[1])
histogram(eig)
hist(eig)
wsd_bincount <- function(eig, grid){
K = length(grid-1)
count = rep(0,K)
for (i in 1:K){
count[i] = length(intersect(which(eig>=grid[i]),which(eig<grid[i+1])))
}
return(count)
}
wsd_bincount(eig, grid)
sum(wsd_bincount(eig, grid))
length(eig)
grid
diff(grid)
grid[1:(length(grid)-1)]+(diff(grid)/2)
library(NetworkDistance)
?nd.wsd
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.dsd(A, out.dist=FALSE, bandwidth=1.0)
image(output$D, main="two group case")
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.dsd(A, out.dist=FALSE, type="Adj")
image(output$D, main="two group case")
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.wsd(A, out.dist=FALSE, K=10)
image(output$D, main="two group case")
warnings()
library(NetworkDistance)
rm(list=ls())
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.wsd(A, out.dist=FALSE, K=10)
image(output$D, main="two group case")
library(NetworkDistance)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.wsd(A, out.dist=FALSE, K=10)
image(output$D, main="two group case")
ls("package:NetworkDistance")
library(NetworkDistance)
library(NetworkDistance)
?dnorm
jsd_kernelsum <- function(x, eigval, bandwidth){
neval  = length(eigval)
output = 0
for (i in 1:neval){
output = output + dnorm(x, mean=eigval[i], sd=bandwidth)
}
return(output)
}
val1 = c(1,2,3,4,5)
bdw1 = 1.0
f = function(x){jsd_kernelsum(x, eigval=val1, bandwidth=bdw1)}
f(1)
f92)
f(2)
f
g = f
g
?integrate
library(NetworkDistance)
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.jsd(A, out.dist=FALSE)
image(output$D, main="two group case")
list_transform <- function(A, NIflag="allowed"){
# 1. size checker
n = nrow(A[[1]])
if (ncol(A[[1]])!=n){
stop("* NetworkDistance : an input list should contain all square matrices.")
}
# 2. transform
listA = list()
for (i in 1:length(A)){
tgt = graph_transform(A[[i]], NIs=NIflag)
if ((nrow(tgt)!=n)||(ncol(tgt)!=n)){
stop(paste("* NetworkDistance : ",i,"-st/rd/th matrix in the list has non-matching size.",sep=""))
}
listA[[i]] = tgt
}
return(listA)
}
graph_transform <- function(obj,NIs="allowed"){
# 1. package:: igraph
if (class(obj)=="igraph"){
output = as_adjacency_matrix(obj)
# 2. package:: network
} else if (class(obj)=="network"){
output = Matrix(as.matrix.network(obj, matrix.type = "adjacency"), sparse=TRUE)
# 3. simple matrix
} else {
output = Matrix(obj, sparse=TRUE)
}
if (NIs!="allowed"){
if ((any(is.na(output)))||(any(is.infinite(output)))){
stop("* NetworkDistance : inputs of NA, Inf, or -Inf are not allowed.")
}
}
return(output)
}
laplacian_unnormalized <- function(matA){
matD = diag(rowSums(matA))-matA
return(matD)
}
laplacian_normalized <- function(matA){
dd = colSums(matA)
Dinv2 = diag(1/dd)
D     = diag(dd)
output = Dinv2%*%(D-matA)%*%Dinv2
return(output)
}
laplacian_signless <- function(matA){
matD = diag(rowSums(matA))+matA
return(matD)
}
listA = list_transform(A, NIflag="not")
require(Matrix)
listA = list_transform(A, NIflag="not")
N     = length(listA)    # number of networks
M     = nrow(listA[[1]]) # number of nodes
sd = as.double(sd)
sd = 0.01
sd = as.double(sd)
if ((length(as.vector(sd))!=1)||(sd<=0)||(is.na(sd))||(is.infinite(sd))){
stop("* nd.jsd : standard deviation parameter should be a positive real number.")
}
mat_eigs = array(0,c(N,M))
mat_dist = array(0,c(N,N))
mat_func = list()
for (i in 1:N){
mat_eigs[i,] = as.vector(eigen(as.matrix(laplacian_normalized(listA[[i]])))$values)
}
listA
tttt = listA[[6]]
tmat = diag(rowSums(tttt))-tttt
tmat
eigen(tmat)
listA = list_transform(A, NIflag="not")
N     = length(listA)    # number of networks
M     = nrow(listA[[1]]) # number of nodes
sd = as.double(sd)
if ((length(as.vector(sd))!=1)||(sd<=0)||(is.na(sd))||(is.infinite(sd))){
stop("* nd.jsd : standard deviation parameter should be a positive real number.")
}
mat_eigs = array(0,c(N,M))
mat_dist = array(0,c(N,N))
mat_func = list()
for (i in 1:N){
mat_eigs[i,] = as.vector(eigen(as.matrix(laplacian_normalized(listA[[i]])))$values)
}
laplacian_normalized(listA[[1]])
laplacian_normalized(listA[[2]])
laplacian_normalized(listA[[3]])
laplacian_normalized(listA[[4]])
listA[[4]]
dd = colSums(listA[[4]])
dd
1/dd
Dinv2[which(is.infinite(Dinv2))]=0
Dinv2 = diag(1/dd)
Dinv2[which(is.infinite(Dinv2))]=0
Dinv2
dd = colSums(matA)
Dinv2 = diag(1/sqrt(dd))
Dinv2[which(is.infinite(Dinv2))]=0
Dinv2
library(NetworkDistance)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.jsd(A, out.dist=FALSE)
f
integrate(f, evals, 1)
integrate(f, 0, 2)
names(integrate(f, 0, 2))
rm(list=ls())
library(NetworkDistance)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.jsd(A, out.dist=FALSE)
output = nd.jsd(A, out.dist=FALSE, sd=0.1)
image(output$D, main="two group case")
output$D
output = nd.jsd(A, out.dist=FALSE, sd=1)
image(output$D, main="two group case")
output = nd.jsd(A, out.dist=FALSE, sd=0.05)
image(output$D, main="two group case")
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.csd(A, out.dist=FALSE, bandwidth=1.0)
image(output$D, main="two group case")
library(NetworkDistance)
A[[1]]
A[[5]]
hey = Matrix(A[[5]],sparse=TRUE)
hey
hey[1,1]
how = Matrix(A[[1]], sparse=TRUE)
how
hey
abs(how-hey)
sum(abs(how-hey))
unique(how)
as.vector(how)
as.vector(how)
as.vector(hey)
how
diag(how)=0
how
M = as.integer(3)
2.3/M
library(NetworkDistance)
?nd.hamming
listA
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
nd.hamming(A)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.csd(A, out.dist=FALSE, bandwidth=1.0)
image(output$D, main="two group case")
output$D
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
?NetworkDistance
library(NetworkDistance)
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.edd(A, out.dist=FALSE)
image(output$D, main="two group case")
mattype1
mattype2
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.1); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.edd(A, out.dist=FALSE)
image(output$D, main="two group case")
mattype1
mattype2
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.1); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.edd(A, out.dist=FALSE)
image(output$D, main="two group case")
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.gdd(A)
library(NetworkDistance)
mattype1
mattype2
mattype1[1,1] = -1
mattype1
mattype1^2
rm(list=ls())
M=3
mat_empty = matrix(rep(0,M*M),nrow=M)
mat_empty = matrix(rep(0,M*M),nrow=M)
mat_full  = matrix(rep(1,M*M),nrow=M); diag(mat_full)=0;
mat_empty
mat_full
10^(seq(from=-2,to=2,length.out=10))
10^(seq(from=-2,to=1,length.out=10))
library(NetworkDistance)
require(igraph)
g <- sample_pa(1000, m = 4)
g
centr_degree(g)$centralization
centr_degree(g)
betweenness(g)
g
betweenness(g)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.1); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype1
g = igraph(mattype1)
g = as.igraph(mattype1)
mattype1
?as.igraph
g = graph_from_adjacency_matrix(mattype1)
g
betweenness(g)
g = graph_from_adjacency_matrix(mattype1, mode="undirected")
g
g
betweenness(g)
degree(g)
betweenness(g)
estimate_betweenness(g)
closeness(g)
mattype1
spmat = Matrix(mattype1, sparse=TRUE)
require(Matrix)
spmat = Matrix(mattype1, sparse=TRUE)
h = graph_from_adjacency_matrix(spmat)
h
h = graph_from_adjacency_matrix(spmat, mode="undirected")
h
?graph_from_adjacency_matrix
?degree
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
?nd.centrality
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## use 3 types of centrality measures
out1 <- nd.centrality(A,out.dist=FALSE,mode="Degree")
out2 <- nd.centrality(A,out.dist=FALSE,mode="Close")
out3 <- nd.centrality(A,out.dist=FALSE,mode="Between")
## visualize
par(mfrow=c(1,3))
image(out1$D, main="Degree")
image(out2$D, main="Closeness")
image(out3$D, main="Betweenness")
library(NetworkDistance)
?nd.him
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.hamming(A)
image(as.matrix(output$D), main="two group case")
graphics.off()
library(NetworkDistance)
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2)
mattype2 = ceiling((mat2+t(mat2))/2)
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## compute distance and visualize
output = nd.him(A, out.dist=FALSE)
image(output$D, main="two group case")
library(NetworkDistance)
?nd.him
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## compute distance and visualize
output = nd.him(A, out.dist=FALSE)
image(output$D, main="two group case")
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
library(NetworkDistance)
## generate two types of adjacency matrices of size (3-by-3)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.1); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.edd(A, out.dist=FALSE)
image(output$D, main="two group case")
library(NetworkDistance)
rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)
rbin2 = rbinom(9,1,0.1); mat2 = matrix(rbin2,nrow=3)
mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;
mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;
A = list()
for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1
for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2
## Compute Distance Matrix and Visualize
output = nd.edd(A, out.dist=FALSE)
image(output$D, main="two group case")
rm(list=ls())
library(NetworkDistance)
ls("package:NetworkDistance")
length(ls("package:NetworkDistance"))
