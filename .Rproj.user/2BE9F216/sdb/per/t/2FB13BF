{
    "collab_server" : "",
    "contents" : "#' Centrality Distance\n#'\n#' Centrality is a core concept in studying the topological structure of\n#' complex networks, which can be either defined for each node or edge.\n#' \\code{nd.centrality} offers 3 distance measures on node-defined centralities.\n#' See this \\href{https://en.wikipedia.org/wiki/Centrality}{Wikipedia page} for more\n#' on network/graph centrality.\n#'\n#' @param A a list of length \\eqn{N} containing \\eqn{(M\\times M)} adjacency matrices.\n#' @param out.dist a logical; \\code{TRUE} for computed distance matrix as a \\code{dist} object.\n#' @param mode type of node centrality definitions to be used.\n#' @param directed a logical; \\code{FALSE} as symmetric, undirected graph.\n#'\n#'\n#' @return a named list containing \\describe{\n#' \\item{D}{an \\eqn{(N\\times N)} matrix or \\code{dist} object containing pairwise distance measures.}\n#' \\item{features}{an \\eqn{(N\\times M)} matrix where rows are node centralities for each graph.}\n#' }\n#'\n#'\n#' @examples\n#' ## generate two types of adjacency matrices of size (3-by-3)\n#' rbin1 = rbinom(9,1,0.8); mat1 = matrix(rbin1,nrow=3)\n#' rbin2 = rbinom(9,1,0.2); mat2 = matrix(rbin2,nrow=3)\n#'\n#' mattype1 = ceiling((mat1+t(mat1))/2); diag(mattype1)=0;\n#' mattype2 = ceiling((mat2+t(mat2))/2); diag(mattype2)=0;\n#'\n#' A = list()\n#' for (i in 1:3){A[[i]]=mattype1} # first 3 are type-1\n#' for (i in 4:6){A[[i]]=mattype2} # next  3 are type-2\n#'\n#' ## use 3 types of centrality measures\n#' out1 <- nd.centrality(A,out.dist=FALSE,mode=\"Degree\")\n#' out2 <- nd.centrality(A,out.dist=FALSE,mode=\"Close\")\n#' out3 <- nd.centrality(A,out.dist=FALSE,mode=\"Between\")\n#'\n#' ## visualize\n#' par(mfrow=c(1,3))\n#' image(out1$D, main=\"Degree\")\n#' image(out2$D, main=\"Closeness\")\n#' image(out3$D, main=\"Betweenness\")\n#'\n#' @references\n#' \\insertRef{roy_modeling_2014}{NetworkDistance}\n#'\n#' @rdname nd_centrality\n#' @export\nnd.centrality <- function(A, out.dist=TRUE,\n                          mode=c(\"Degree\",\"Close\",\"Between\"),\n                          directed=FALSE){\n  #-------------------------------------------------------\n  ## PREPROCESSING\n  # 1. list of length larger than 1\n  if ((!is.list(A))||(length(A)<=1)){\n    stop(\"* nd.csd : input 'A' should be a list of length larger than 1.\")\n  }\n  # 2. transform the data while checking\n  listA = list_transform(A, NIflag=\"not\")\n  N     = length(listA)\n  M     = nrow(listA[[1]])\n  # 3. out.dist & directed\n  if ((!is.logical(out.dist))||(!is.logical(directed))){\n    stop(\"* nd.centrality : 'out.dist' and 'directed' should be logical variables.\")\n  }\n  # 4. mode\n  if (missing(mode)){\n    mode = \"Degree\"\n  } else {\n    mode = match.arg(mode)\n  }\n\n  #-------------------------------------------------------\n  ## MAIN COMPUTATION\n  #   1. prepare for the results\n  mat_features = array(0,c(N,M))\n  mat_dist = array(0,c(N,N))\n  #   2. transform into igraph objects & compute characteristics\n  for (i in 1:N){\n    #   2-1. transform\n    if (directed==FALSE){\n      tgt = graph_from_adjacency_matrix(listA[[i]], mode=\"undirected\")\n    } else {\n      tgt = graph_from_adjacency_matrix(listA[[i]], mode=\"directed\")\n    }\n    #   2-2. compute features & record\n    if (mode==\"Degree\"){\n      mat_features[i,] = as.vector(igraph::degree(tgt))\n    } else if (mode==\"Close\"){\n      mat_features[i,] = as.vector(igraph::closeness(tgt))\n    } else if (mode==\"Between\"){\n      mat_features[i,] = as.vector(igraph::betweenness(tgt))\n    }\n  }\n  #   3. compute pairwise distances\n  for (i in 1:(N-1)){\n    vec1 = mat_features[i,]\n    for (j in (i+1):N){\n      vec2     = mat_features[j,]\n      solution = sum(abs(vec1-vec2))\n\n      mat_dist[i,j] = solution\n      mat_dist[j,i] = solution\n    }\n  }\n\n  #-------------------------------------------------------\n  ## RETURN RESULTS\n  if (out.dist){\n    mat_dist = as.dist(mat_dist)\n  }\n\n  result = list()\n  result$D= mat_dist\n  result$features = mat_features\n  return(result)\n}\n",
    "created" : 1512666290840.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3677598838",
    "id" : "2FB13BF",
    "lastKnownWriteTime" : 1512665720,
    "last_content_update" : 1512665720,
    "path" : "~/Desktop/NetworkDistance/R/nd_centrality.R",
    "project_path" : "R/nd_centrality.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}